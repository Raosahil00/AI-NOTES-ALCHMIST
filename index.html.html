<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Note Alchemist (Polished)</title>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&family=Indie+Flower&display=swap" rel="stylesheet">
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/rough.js/3.1.0/rough.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        body {
            background-color: #f4f7f6;
            margin: 0;
            font-family: 'Patrick Hand', cursive;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
        }

        /* --- SIDEBAR OVERLAY (The Grimoire) --- */
        .sidebar {
            width: 300px;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(10px);
            color: white;
            height: 100vh;
            position: fixed;
            left: -320px; /* Hidden */
            top: 0;
            transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 2000;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            box-shadow: 5px 0 15px rgba(0,0,0,0.3);
        }
        .sidebar.open { left: 0; }
        
        .sidebar-header {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 15px; margin-bottom: 20px;
        }
        .sidebar h2 { margin: 0; font-size: 1.8rem; }
        .close-sidebar { cursor: pointer; font-size: 1.5rem; color: #ecf0f1; }

        .saved-note-item {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid transparent;
        }
        .saved-note-item:hover { background: rgba(255,255,255,0.2); transform: translateX(5px); }
        .saved-note-title { font-weight: bold; font-size: 1.1rem; }
        .saved-note-date { font-size: 0.8rem; color: #bdc3c7; margin-top: 4px; }
        .delete-btn { color: #e74c3c; padding: 5px; border-radius: 4px; transition: background 0.2s; }
        .delete-btn:hover { background: rgba(231, 76, 60, 0.2); }

        .toggle-sidebar-btn {
            position: fixed;
            left: 20px;
            top: 20px;
            z-index: 1001;
            background: white;
            color: #2c3e50;
            border: 2px solid #2c3e50;
            width: 45px; height: 45px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.4rem;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }
        .toggle-sidebar-btn:hover { transform: scale(1.1); }

        /* --- BACKDROP --- */
        .sidebar-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 1500;
            display: none; opacity: 0; transition: opacity 0.3s;
        }
        .sidebar-backdrop.active { display: block; opacity: 1; }

        /* --- MAIN VIEW --- */
        .view-container {
            width: 100%;
            max-width: 900px;
            padding: 20px;
            padding-top: 80px; /* Space for toggle button */
            box-sizing: border-box;
        }
        .hidden { display: none !important; }

        /* Input Card */
        .input-card {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.08);
            border: 1px solid rgba(0,0,0,0.05);
            text-align: center;
        }
        h1 { color: #2c3e50; margin: 0 0 10px 0; font-size: 3rem; }
        .subtitle { color: #7f8c8d; margin-bottom: 30px; font-size: 1.3rem; }

        textarea {
            width: 100%;
            height: 180px;
            padding: 15px;
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 16px;
            resize: vertical;
            box-sizing: border-box;
            margin-bottom: 25px;
            transition: border-color 0.3s;
        }
        textarea:focus { outline: none; border-color: #f1c40f; background: #fffdf9; }

        /* Buttons */
        .button-group { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
        
        button {
            font-family: 'Patrick Hand', cursive; font-size: 1.2rem; padding: 12px 24px; cursor: pointer;
            border: 2px solid #2c3e50; border-radius: 10px; display: flex; align-items: center; gap: 8px;
            transition: all 0.2s; box-shadow: 0 4px 0 #2c3e50;
        }
        button:active { transform: translateY(4px); box-shadow: 0 0 0 #2c3e50; }
        button:disabled { background: #ecf0f1 !important; color: #bdc3c7; border-color: #bdc3c7; box-shadow: none; cursor: not-allowed; }

        .btn-primary { background: #f1c40f; color: #2c3e50; }
        .btn-primary:hover { background: #f39c12; }
        
        .btn-secondary { background: #dff9fb; color: #2c3e50; }
        .btn-secondary:hover { background: #c7ecee; }

        .btn-vision { background: #ffccbc; color: #d35400; border-color: #d35400; box-shadow: 0 4px 0 #d35400; }
        .btn-vision:active { box-shadow: 0 0 0 #d35400; }

        .file-upload-wrapper { position: relative; overflow: hidden; }
        .file-upload-wrapper input[type=file] { position: absolute; left: 0; top: 0; opacity: 0; width: 100%; height: 100%; cursor: pointer; }

        /* --- OUTPUT TOOLBAR --- */
        .toolbar-container {
            background: white;
            padding: 15px 25px;
            border-radius: 50px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.08);
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 25px;
            border: 1px solid #eee;
        }

        .color-dot { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 3px solid white; box-shadow: 0 0 0 1px #ddd; transition: transform 0.2s; }
        .color-dot.active { transform: scale(1.2); box-shadow: 0 0 0 2px #2c3e50; }

        select { padding: 8px 12px; border-radius: 20px; border: 1px solid #ddd; font-family: 'Patrick Hand', cursive; font-size: 1rem; cursor: pointer; background: #f9f9f9; }
        
        .highlighter-btn { background: #fff9c4; border: 1px solid #fbc02d; padding: 8px 16px; border-radius: 20px; cursor: pointer; font-size: 1rem; }
        .highlighter-btn.active { background: #ffeb3b; box-shadow: inset 0 2px 5px rgba(0,0,0,0.1); font-weight: bold; }

        .undo-btn { 
            background: #e0e0e0; border: 1px solid #bdc3c7; padding: 8px 12px; 
            border-radius: 20px; cursor: pointer; font-size: 1.2rem; min-width: 40px; 
        }
        .undo-btn:hover { background: #d0d0d0; }

        /* Slider Controls */
        .slider-control { display: flex; flex-direction: column; align-items: center; font-size: 0.8rem; color: #555; }
        .slider-control label { margin-bottom: 2px; font-weight: bold; }
        input[type=range] { cursor: pointer; width: 80px; }

        /* --- CANVAS --- */
        .canvas-wrapper {
            position: relative;
            background: white;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            border-radius: 4px;
            overflow: hidden;
        }
        .canvas-wrapper.highlighting { cursor: crosshair; }
        canvas { display: block; }

        /* --- PAGINATION --- */
        .pagination { display: flex; align-items: center; justify-content: center; gap: 20px; margin-top: 20px; font-size: 1.3rem; }
        .page-arrow { 
            background: white; border: 2px solid #2c3e50; width: 45px; height: 45px; border-radius: 50%; 
            display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background 0.2s;
        }
        .page-arrow:hover { background: #f1c40f; }

        /* Status */
        #status { text-align: center; color: #7f8c8d; margin-top: 15px; font-size: 1.1rem; height: 24px; font-weight: bold; }
    </style>
</head>
<body>

    <!-- SIDEBAR & BACKDROP -->
    <div id="sidebarBackdrop" class="sidebar-backdrop" onclick="toggleSidebar()"></div>
    <div id="grimoireSidebar" class="sidebar">
        <div class="sidebar-header">
            <h2>üìö Grimoire</h2>
            <div class="close-sidebar" onclick="toggleSidebar()">‚úï</div>
        </div>
        <div id="savedNotesList">
            <p style="text-align:center; color:rgba(255,255,255,0.5);">No notes yet.<br>Go create some magic! ‚ú®</p>
        </div>
    </div>
    
    <button class="toggle-sidebar-btn" onclick="toggleSidebar()">üìñ</button>

    <!-- INPUT VIEW -->
    <div id="inputView" class="view-container">
        <div class="input-card">
            <h1>‚ú® AI Note Alchemist</h1>
            <p class="subtitle">Turn raw text or images into structured handwritten notes.</p>
            
            <textarea id="userInput" placeholder="Paste your study notes, lecture transcript, or just a topic name..."></textarea>
            
            <div class="button-group">
                <button class="btn-primary" onclick="generateNotes('standard')">üìù Create Notes</button>
                <button class="btn-secondary" onclick="generateNotes('simple')">üë∂ Explain Simply</button>
                
                <div class="file-upload-wrapper">
                    <button class="btn-vision">üì∑ Scan Image</button>
                    <input type="file" id="imageInput" accept="image/*" onchange="handleImageUpload(this)">
                </div>
            </div>
            <p id="status"></p>
        </div>
    </div>

    <!-- OUTPUT VIEW -->
    <div id="outputView" class="view-container hidden">
        
        <!-- Action Bar -->
        <div class="toolbar-container" style="justify-content: space-between; background: transparent; box-shadow: none; padding: 0; border: none;">
            <button class="btn-secondary" onclick="resetApp()" style="padding: 8px 16px; font-size: 1rem;">‚Üê New</button>
            <button class="btn-primary" id="downloadBtn" onclick="downloadPDF()" style="padding: 8px 16px; font-size: 1rem;">‚¨á Download PDF</button>
        </div>

        <!-- Customization Toolbar -->
        <div class="toolbar-container">
            <div class="color-dot active" style="background:#2c3e50;" onclick="setInkColor('#2c3e50', this)"></div>
            <div class="color-dot" style="background:#1a237e;" onclick="setInkColor('#1a237e', this)"></div>
            <div class="color-dot" style="background:#b71c1c;" onclick="setInkColor('#b71c1c', this)"></div>
            <div class="color-dot" style="background:#1b5e20;" onclick="setInkColor('#1b5e20', this)"></div>
            
            <div style="width: 1px; height: 25px; background: #ddd; margin: 0 5px;"></div>
            
            <select onchange="setPaperStyle(this.value)">
                <option value="lined">Lined Paper</option>
                <option value="grid">Grid Paper</option>
                <option value="dots">Dot Matrix</option>
                <option value="blank">Blank</option>
            </select>
            
            <div class="slider-control">
                <label>Line Gap</label>
                <input type="range" min="30" max="70" value="40" oninput="setLineHeight(this.value)">
            </div>

            <div style="width: 1px; height: 25px; background: #ddd; margin: 0 5px;"></div>

            <select onchange="setFontStyle(this.value)">
                <option value="Patrick Hand">Neat Font</option>
                <option value="Indie Flower">Messy Font</option>
            </select>
            
            <div style="width: 1px; height: 25px; background: #ddd; margin: 0 5px;"></div>

            <!-- Highlighter Controls -->
            <button id="highlighterBtn" class="highlighter-btn" onclick="toggleHighlighter()">üñçÔ∏è</button>
            <div class="slider-control">
                <label>Marker Size</label>
                <input type="range" min="5" max="50" value="20" oninput="setHighlighterSize(this.value)">
            </div>
            
            <button class="undo-btn" onclick="undoHighlight()" title="Undo">‚Ü©</button>
            <button class="undo-btn" onclick="redoHighlight()" title="Redo">‚Ü™</button>
        </div>

        <div id="canvasWrapper" class="canvas-wrapper">
            <canvas id="paperCanvas" width="800" height="1000"></canvas>
        </div>
        
        <div class="pagination" id="paginationControls" style="display:none;">
            <div class="page-arrow" onclick="changePage(-1)">‚Üê</div>
            <span id="pageIndicator" style="font-weight:bold; color:#2c3e50;">Page 1</span>
            <div class="page-arrow" onclick="changePage(1)">‚Üí</div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const apiKey = ""; // Environment variable handles this

        const canvas = document.getElementById('paperCanvas');
        const ctx = canvas.getContext('2d');
        let rc;
        
        // App State
        let allPages = [];
        let currentPageIndex = 0;
        let currentRawData = null; // Store raw data for re-pagination
        
        // Visual Customization State
        let currentInk = '#2c3e50';
        let currentPaper = 'lined';
        let currentFont = 'Patrick Hand';
        let currentLineHeight = 40; 
        
        // Highlighter State
        let isHighlighting = false;
        let isDrawing = false;
        let currentHighlighterSize = 20;

        // Constants
        const PAGE_MARGIN = 50;
        const CONTENT_HEIGHT_LIMIT = 920; 

        // Init
        window.addEventListener('load', () => {
             document.getElementById('inputView').classList.remove('hidden');
             if (typeof rough !== 'undefined') {
                 rc = rough.canvas(canvas);
             } else {
                 alert("Critical Error: Rough.js library failed to load.");
             }
             loadGrimoire();
             
             // Canvas Event Listeners
             canvas.addEventListener('mousedown', startHighlight);
             canvas.addEventListener('mousemove', drawHighlight);
             canvas.addEventListener('mouseup', stopHighlight);
             canvas.addEventListener('mouseout', stopHighlight);
        });

        // --- GRIMOIRE (SIDEBAR) ---
        function toggleSidebar() {
            document.getElementById('grimoireSidebar').classList.toggle('open');
            document.getElementById('sidebarBackdrop').classList.toggle('active');
        }

        function saveNoteToGrimoire(data) {
            if(!data || !data.title) return;
            let library = JSON.parse(localStorage.getItem('ai_notes_library') || '[]');
            const noteId = Date.now().toString();
            const existing = library.find(n => n.title === data.title);
            if(existing) return; 

            const newNote = { id: noteId, title: data.title, date: new Date().toLocaleDateString(), data: data };
            library.unshift(newNote);
            if (library.length > 20) library.pop();
            localStorage.setItem('ai_notes_library', JSON.stringify(library));
            loadGrimoire();
        }

        function loadGrimoire() {
            const list = document.getElementById('savedNotesList');
            const library = JSON.parse(localStorage.getItem('ai_notes_library') || '[]');
            list.innerHTML = '';
            
            if (library.length === 0) {
                list.innerHTML = '<p style="text-align:center; color:rgba(255,255,255,0.5); margin-top:20px;">No notes yet.<br>Go create some magic! ‚ú®</p>';
                return;
            }

            library.forEach(note => {
                const item = document.createElement('div');
                item.className = 'saved-note-item';
                item.innerHTML = `
                    <div onclick="loadSavedNote('${note.id}')" style="flex-grow:1;">
                        <div class="saved-note-title">${note.title}</div>
                        <div class="saved-note-date">${note.date}</div>
                    </div>
                    <div class="delete-btn" onclick="deleteNote('${note.id}')">‚úï</div>
                `;
                list.appendChild(item);
            });
        }

        function loadSavedNote(id) {
            const library = JSON.parse(localStorage.getItem('ai_notes_library') || '[]');
            const note = library.find(n => n.id === id);
            if (note) {
                currentRawData = note.data;
                paginateData(note.data);
                switchView('output');
                renderPage(0);
                toggleSidebar();
            }
        }

        function deleteNote(id) {
            let library = JSON.parse(localStorage.getItem('ai_notes_library') || '[]');
            library = library.filter(n => n.id !== id);
            localStorage.setItem('ai_notes_library', JSON.stringify(library));
            loadGrimoire();
        }

        // --- CUSTOMIZATION ---
        function setInkColor(color, el) {
            currentInk = color;
            document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
            el.classList.add('active');
            renderPage(currentPageIndex);
        }
        function setPaperStyle(style) { currentPaper = style; renderPage(currentPageIndex); }
        function setFontStyle(font) { currentFont = font; renderPage(currentPageIndex); }
        
        function setLineHeight(val) {
            currentLineHeight = parseInt(val);
            if(currentRawData) {
                paginateData(currentRawData);
                renderPage(0); 
            }
        }

        function toggleHighlighter() {
            isHighlighting = !isHighlighting;
            const btn = document.getElementById('highlighterBtn');
            const wrap = document.getElementById('canvasWrapper');
            if(isHighlighting) { btn.classList.add('active'); wrap.classList.add('highlighting'); }
            else { btn.classList.remove('active'); wrap.classList.remove('highlighting'); }
        }

        function setHighlighterSize(val) {
            currentHighlighterSize = parseInt(val);
        }

        // --- HIGHLIGHTER & UNDO/REDO ---
        function startHighlight(e) {
            if (!isHighlighting) return;
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            if (!allPages[currentPageIndex].highlights) allPages[currentPageIndex].highlights = [];
            
            // Start new stroke
            allPages[currentPageIndex].highlights.push({
                points: [{
                    x: (e.clientX - rect.left) * (canvas.width / rect.width),
                    y: (e.clientY - rect.top) * (canvas.height / rect.height)
                }],
                size: currentHighlighterSize
            });
            const lastStroke = allPages[currentPageIndex].highlights.at(-1);
            drawHighlightLine(lastStroke.points, lastStroke.size);
        }

        function drawHighlight(e) {
            if (!isHighlighting || !isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const stroke = allPages[currentPageIndex].highlights.at(-1);
            stroke.points.push({
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            });
            drawHighlightLine(stroke.points, stroke.size);
        }

        function stopHighlight() { 
            if(isDrawing) {
                isDrawing = false; 
                // Clear redo stack on new action
                if(allPages[currentPageIndex]) allPages[currentPageIndex].redoStack = [];
            }
        }
        
        function drawHighlightLine(points, size) {
            if (points.length < 2) return;
            ctx.save(); // Save current state
            ctx.globalCompositeOperation = 'multiply'; // Key fix: Allows text to show through
            ctx.beginPath();
            ctx.strokeStyle = "rgba(255, 235, 59, 0.5)"; // Slightly more vibrant, but transparent
            ctx.lineWidth = size;
            ctx.lineCap = "round"; 
            ctx.lineJoin = "round";
            ctx.moveTo(points.at(-2).x, points.at(-2).y);
            ctx.lineTo(points.at(-1).x, points.at(-1).y);
            ctx.stroke();
            ctx.restore(); // Restore to normal drawing mode
        }

        function renderAllHighlights(highlights) {
            if (!highlights) return;
            ctx.save();
            ctx.globalCompositeOperation = 'multiply'; // Ensure saved highlights also blend
            ctx.lineCap = "round"; 
            ctx.lineJoin = "round";
            ctx.strokeStyle = "rgba(255, 235, 59, 0.5)";
            
            highlights.forEach(stroke => {
                if(stroke.points.length<2) return;
                ctx.beginPath();
                ctx.lineWidth = stroke.size || 20; 
                ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for(let i=1; i<stroke.points.length; i++) ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                ctx.stroke();
            });
            ctx.restore();
        }

        function undoHighlight() {
            const page = allPages[currentPageIndex];
            if (page && page.highlights && page.highlights.length > 0) {
                if (!page.redoStack) page.redoStack = [];
                const stroke = page.highlights.pop();
                page.redoStack.push(stroke);
                renderPage(currentPageIndex);
            }
        }

        function redoHighlight() {
            const page = allPages[currentPageIndex];
            if (page && page.redoStack && page.redoStack.length > 0) {
                const stroke = page.redoStack.pop();
                page.highlights.push(stroke);
                renderPage(currentPageIndex);
            }
        }

        // --- API & GENERATION ---
        function switchView(name) {
            document.querySelectorAll('.view-container').forEach(v => v.classList.add('hidden'));
            document.getElementById(name+'View').classList.remove('hidden');
        }
        function resetApp() {
            switchView('input');
            document.getElementById('userInput').value = '';
            document.getElementById('status').innerText = '';
            
            // Check if element exists before setting value
            const imageInput = document.getElementById('imageInput');
            if(imageInput) imageInput.value = ''; 
        }

        async function handleImageUpload(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const reader = new FileReader();
                document.getElementById('status').innerText = "üì∑ Analyzing Image... (This might take a moment)";
                document.querySelectorAll('button').forEach(b => b.disabled = true);

                reader.onload = async function(e) {
                    const base64 = e.target.result.split(',')[1];
                    try {
                        // FIXED PROMPT: Explicit schema for each type
                        const prompt = `Analyze image and return JSON with this specific schema:
                        {
                          "title": "Main Title",
                          "sections": [
                            { "type": "definition_box", "heading": "Heading", "content": "String text", "icon": "book" },
                            { "type": "bullet_list", "heading": "Heading", "points": ["Point 1", "Point 2"], "icon": "star" },
                            { "type": "flowchart", "heading": "Process", "steps": ["Step 1", "Step 2"], "icon": "time" },
                            { "type": "mind_map", "heading": "Concept", "center": "Core Idea", "branches": ["Branch A", "Branch B"], "icon": "bulb" }
                          ]
                        }
                        Rules:
                        1. "content" MUST be a string. "points", "steps", "branches" MUST be arrays of strings.
                        2. Add 'icon' field (star, bulb, time, warning, book, target) based on context.`;
                        
                        const txt = await callGeminiVisionAPI(prompt, base64, file.type);
                        const data = JSON.parse(txt.replace(/```json/g, '').replace(/```/g, '').trim());
                        currentRawData = data;
                        saveNoteToGrimoire(data);
                        paginateData(data);
                        switchView('output'); renderPage(0);
                    } catch(err) { alert("Error: "+err.message); }
                    finally { document.querySelectorAll('button').forEach(b => b.disabled = false); document.getElementById('status').innerText = "";}
                };
                reader.readAsDataURL(file);
            }
        }

        async function callGeminiVisionAPI(txt, img, mime) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            const body = { contents: [{ parts: [{ text: txt }, { inlineData: { mimeType: mime, data: img } }] }] };
            const res = await fetch(url, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(body) });
            const d = await res.json();
            if(!res.ok) throw new Error(d.error?.message);
            return d.candidates[0].content.parts[0].text;
        }

        async function generateNotes(mode) {
            if (!rc) return;
            const text = document.getElementById('userInput').value.trim();
            if (!text) { alert("Please enter some text!"); return; }
            
            document.querySelectorAll('button').forEach(b => b.disabled = true);
            document.getElementById('status').innerText = "‚ú® Transmuting...";

            try {
                let instruct = "Act as a smart note organizer. Return valid JSON only.";
                if (mode === 'simple') instruct += " Simplify content for a 5-year-old.";
                
                // FIXED PROMPT: Explicit schema to prevent "object" errors
                const prompt = `Analyze text and return JSON with this specific schema:
                {
                  "title": "Main Title",
                  "sections": [
                    { 
                      "type": "definition_box", 
                      "heading": "Heading", 
                      "content": "A string paragraph of text.", 
                      "icon": "book" 
                    },
                    { 
                      "type": "bullet_list", 
                      "heading": "Heading", 
                      "points": ["Point 1 string", "Point 2 string"], 
                      "icon": "star" 
                    },
                    { 
                      "type": "flowchart", 
                      "heading": "Process", 
                      "steps": ["Step 1 string", "Step 2 string"], 
                      "icon": "time" 
                    },
                    { 
                      "type": "mind_map", 
                      "heading": "Concept", 
                      "center": "Central Idea string", 
                      "branches": ["Branch 1 string", "Branch 2 string"], 
                      "icon": "bulb" 
                    }
                  ]
                }
                Rules:
                1. "content" MUST be a string. "points", "steps", "branches" MUST be arrays of strings.
                2. Add 'icon' field (star, bulb, time, warning, book, target) based on context.
                Text: ${text}`;
                
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                const res = await fetch(url, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }], systemInstruction: { parts: [{ text: instruct }] } }) });
                const d = await res.json();
                if(!res.ok) throw new Error(d.error?.message);
                
                const data = JSON.parse(d.candidates[0].content.parts[0].text.replace(/```json/g, '').replace(/```/g, '').trim());
                currentRawData = data;
                saveNoteToGrimoire(data);
                paginateData(data);
                switchView('output'); renderPage(0);
            } catch (err) { alert("Error: " + err.message); }
            finally { document.querySelectorAll('button').forEach(b => b.disabled = false); document.getElementById('status').innerText = ""; }
        }

        // --- PAGINATION & RENDERING ---
        function paginateData(data) {
            allPages = [];
            let currentPage = { title: null, sections: [], highlights: [], redoStack: [] }; 
            let currentY = PAGE_MARGIN + 20;
            const MAX_H = CONTENT_HEIGHT_LIMIT;

            if (data.title) { currentPage.title = data.title; currentY += 60; }
            
            if (data.sections) {
                data.sections.forEach(section => {
                    let h = 0;
                    if (section.type === 'definition_box') h = 70 + measureWrappedTextHeight(section.content, 700, currentLineHeight);
                    else if (section.type === 'bullet_list') h = 40 + measureListHeight(section.points);
                    else if (section.type === 'flowchart') h = 50 + (section.steps.length * 60) + ((section.steps.length - 1) * 30) + 40;
                    else if (section.type === 'mind_map') h = 420; 

                    if (currentY + h > MAX_H) {
                        allPages.push(currentPage);
                        currentPage = { title: null, sections: [], highlights: [], redoStack: [] };
                        currentY = PAGE_MARGIN + 20;
                    }
                    currentPage.sections.push(section);
                    currentY += h;
                });
            }
            if (currentPage.sections.length > 0 || currentPage.title) allPages.push(currentPage);
            currentPageIndex = 0; 
            updatePaginationUI();
        }

        function measureListHeight(points) {
            let h = 0;
            points.forEach(p => h += measureWrappedTextHeight(p, 700, currentLineHeight) + 10);
            return h; 
        }

        function renderPage(index) {
            currentPageIndex = index;
            const pageData = allPages[index];
            
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawPaperBackground();
            if(pageData.highlights) renderAllHighlights(pageData.highlights);

            let cursorY = PAGE_MARGIN + 20;
            if(!pageData.title) cursorY = PAGE_MARGIN;
            if (pageData.title) { drawTitle(pageData.title, cursorY); cursorY += 60; }

            pageData.sections.forEach(section => {
                // Draw Icon if present
                if(section.icon) drawIcon(section.icon, PAGE_MARGIN + 680, cursorY + 10);

                if (section.type === 'definition_box') cursorY = drawDefinitionBox(section.heading, section.content, cursorY);
                else if (section.type === 'bullet_list') cursorY = drawBulletList(section.heading, section.points, cursorY);
                else if (section.type === 'flowchart') cursorY = drawFlowchart(section.heading, section.steps, cursorY);
                else if (section.type === 'mind_map') cursorY = drawMindMap(section.heading, section.center, section.branches, cursorY);
            });
            updatePaginationUI();
        }

        function drawPaperBackground() {
            if (currentPaper === 'blank') return;
            ctx.strokeStyle = "#a8d1ff"; ctx.lineWidth = 1;
            const spacing = currentLineHeight;

            if (currentPaper === 'lined') {
                for (let y = spacing; y < canvas.height; y += spacing) { 
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); 
                }
                ctx.beginPath(); ctx.strokeStyle = "#ffcdd2"; ctx.lineWidth = 2; ctx.moveTo(PAGE_MARGIN - 20, 0); ctx.lineTo(PAGE_MARGIN - 20, canvas.height); ctx.stroke();
            } else if (currentPaper === 'grid') {
                for (let x = 0; x < canvas.width; x += spacing) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
                for (let y = 0; y < canvas.height; y += spacing) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
            } else if (currentPaper === 'dots') {
                ctx.fillStyle = "#a8d1ff";
                for (let x = 30; x < canvas.width; x += spacing) { for (let y = 30; y < canvas.height; y += spacing) { ctx.beginPath(); ctx.arc(x, y, 1, 0, Math.PI * 2); ctx.fill(); } }
            }
        }

        // --- NEW: SMART DOODLER DRAWING FUNCTIONS ---
        function drawIcon(type, x, y) {
            ctx.save();
            ctx.strokeStyle = currentInk;
            ctx.fillStyle = "rgba(255, 235, 59, 0.2)"; // Subtle highlight fill
            ctx.lineWidth = 2;
            
            if(type === 'star') {
                // 5-point star
                rc.path(`M${x},${y} l5,15 l15,0 l-12,10 l5,15 l-13,-10 l-13,10 l5,-15 l-12,-10 l15,0 z`, {stroke:currentInk, fill:'rgba(255,215,0,0.4)', fillStyle:'solid', roughness:1});
            } else if(type === 'bulb') {
                // Lightbulb
                rc.circle(x+10, y+10, 20, {stroke:currentInk});
                rc.line(x+5, y+20, x+15, y+20, {stroke:currentInk}); // base
                rc.line(x+10, y+20, x+10, y+25, {stroke:currentInk});
                // Rays
                rc.line(x+10, y-5, x+10, y-10, {stroke:currentInk});
                rc.line(x-5, y+5, x-10, y, {stroke:currentInk});
                rc.line(x+25, y+5, x+30, y, {stroke:currentInk});
            } else if(type === 'time') {
                // Clock
                rc.circle(x+15, y+15, 30, {stroke:currentInk});
                rc.line(x+15, y+15, x+15, y+5, {stroke:currentInk}); // Hand 1
                rc.line(x+15, y+15, x+25, y+15, {stroke:currentInk}); // Hand 2
            } else if(type === 'warning') {
                // Triangle
                rc.path(`M${x+15},${y} l15,30 l-30,0 z`, {stroke:currentInk, fill:'rgba(255,0,0,0.1)', fillStyle:'solid'});
                rc.line(x+15, y+10, x+15, y+20, {stroke:currentInk, strokeWidth:2}); // Exclamation
                rc.circle(x+15, y+25, 2, {fill:currentInk, fillStyle:'solid'});
            } else if(type === 'book') {
                // Open book
                rc.path(`M${x},${y+20} q10,5 20,0 q10,5 20,0 l0,-15 q-10,5 -20,0 q-10,5 -20,0 z`, {stroke:currentInk});
                rc.line(x+20, y+5, x+20, y+20, {stroke:currentInk}); // Spine
            } else if(type === 'target') {
                // Arrow/Target
                rc.circle(x+15, y+15, 25, {stroke:currentInk});
                rc.circle(x+15, y+15, 10, {stroke:currentInk, fill:'rgba(255,0,0,0.1)', fillStyle:'solid'});
            }
            
            ctx.restore();
        }

        function drawTitle(t, y) { 
            ctx.font = `bold 40px '${currentFont}'`; ctx.fillStyle = currentInk; ctx.fillText(t, PAGE_MARGIN, y); 
            rc.line(PAGE_MARGIN, y+5, PAGE_MARGIN+300, y+5, {roughness:2, stroke:currentInk}); 
        }

        function drawDefinitionBox(h, c, y) {
            let startY = y; 
            ctx.font = `bold 24px '${currentFont}'`; ctx.fillStyle = currentInk; ctx.fillText(h, PAGE_MARGIN+10, y); y+=30;
            ctx.font = `20px '${currentFont}'`; 
            let th = wrapText(ctx, c, PAGE_MARGIN+10, y, 700, currentLineHeight);
            y = th+currentLineHeight;
            rc.rectangle(PAGE_MARGIN, startY-25, 720, y-startY+10, {roughness:1.5, stroke:"#555", strokeWidth:1, bowing:2});
            return y+40;
        }

        function drawBulletList(h, p, y) {
            ctx.font = `bold 24px '${currentFont}'`; ctx.fillStyle = currentInk; ctx.fillText(h, PAGE_MARGIN, y); y+=35;
            ctx.font = `20px '${currentFont}'`;
            p.forEach(pt => { 
                rc.circle(PAGE_MARGIN+10, y-7, 8, {fill:currentInk, fillStyle:'solid', roughness:0.5}); 
                y = wrapText(ctx, pt, PAGE_MARGIN+30, y, 700, currentLineHeight);
                y += currentLineHeight; 
            });
            return y+30;
        }

        function drawFlowchart(h, s, y) {
            ctx.font = `bold 24px '${currentFont}'`; ctx.fillStyle = currentInk; ctx.fillText("üîÑ "+h, PAGE_MARGIN, y); y+=40;
            let cx = canvas.width/2;
            s.forEach((step,i) => {
                rc.rectangle(cx-150, y, 300, 50, {roughness:2, stroke:currentInk});
                ctx.font = `20px '${currentFont}'`; ctx.fillStyle = currentInk; 
                ctx.fillText(step, cx - (ctx.measureText(step).width/2), y+33);
                y+=50;
                if(i<s.length-1) { rc.line(cx,y,cx,y+30,{stroke:currentInk}); y+=30; }
            });
            return y+40;
        }

        function drawMindMap(heading, centerText, branches, y) {
            ctx.font = `bold 24px '${currentFont}'`; ctx.fillStyle = currentInk; ctx.fillText("üß† "+heading, PAGE_MARGIN, y); y+=40;
            const cx = canvas.width / 2;
            const cy = y + 180; 
            rc.circle(cx, cy, 100, {roughness:2, stroke:currentInk, strokeWidth:2, fill:"rgba(255,235,59,0.1)", fillStyle:'solid'});
            ctx.font = `bold 22px '${currentFont}'`; ctx.fillStyle = currentInk;
            const centerWidth = ctx.measureText(centerText).width;
            ctx.fillText(centerText, cx - (centerWidth/2), cy + 7);
            const angleStep = (2 * Math.PI) / branches.length;
            branches.forEach((branch, i) => {
                const angle = i * angleStep;
                const radius = 140 + (i % 2) * 60; 
                const bx = cx + Math.cos(angle) * radius;
                const by = cy + Math.sin(angle) * radius;
                rc.line(cx, cy, bx, by, {roughness: 1.5, stroke: currentInk});
                rc.circle(bx, by, 80, {roughness:1, stroke:currentInk, fill:"#fff", fillStyle:'solid'});
                ctx.font = `18px '${currentFont}'`; ctx.fillStyle = currentInk;
                const maxW = 70; const lH = 20;
                const txtH = measureWrappedTextHeight(String(branch), maxW, lH);
                let tY = by - (txtH / 2) + (lH / 2);
                wrapText(ctx, String(branch), bx - (maxW/2), tY, maxW, lH);
            });
            return y + 420;
        }

        function measureWrappedTextHeight(t, mw, lh) {
            t = String(t || ""); ctx.font = `20px '${currentFont}'`;
            let words = t.split(' '), line = '', h = 0;
            for(let i=0; i<words.length; i++) {
                if(ctx.measureText(line + words[i] + ' ').width > mw && i > 0) { line = words[i] + ' '; h += lh; }
                else line += words[i] + ' ';
            }
            return h + lh;
        }

        function wrapText(c, t, x, y, mw, lh) {
            t = String(t || "");
            let words = t.split(' '), line = '';
            for(let i=0; i<words.length; i++) {
                if(c.measureText(line + words[i] + ' ').width > mw && i > 0) { c.fillText(line, x, y); line = words[i] + ' '; y += lh; }
                else line += words[i] + ' ';
            }
            c.fillText(line, x, y);
            return y;
        }

        function updatePaginationUI() {
            const c = document.getElementById('paginationControls');
            if(allPages.length > 1) { 
                c.style.display='flex'; 
                document.getElementById('pageIndicator').innerText = `Page ${currentPageIndex+1} of ${allPages.length}`; 
            } else c.style.display='none';
        }
        function changePage(d) { let n=currentPageIndex+d; if(n>=0 && n<allPages.length) renderPage(n); }
        
        async function downloadPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'p', unit: 'pt', format: [canvas.width, canvas.height] });
            const idx = currentPageIndex;
            const btn = document.getElementById('downloadBtn');
            const txt = btn.innerText; btn.innerText = "‚è≥ Generating..."; btn.disabled = true;

            try {
                for (let i = 0; i < allPages.length; i++) {
                    if (i > 0) doc.addPage();
                    renderPage(i);
                    const img = canvas.toDataURL('image/jpeg', 0.95);
                    doc.addImage(img, 'JPEG', 0, 0, canvas.width, canvas.height);
                }
                doc.save("ai-notes.pdf");
                renderPage(idx);
            } catch (err) { alert("PDF Error"); } 
            finally { btn.innerText = txt; btn.disabled = false; }
        }
    </script>
</body>
</html>
